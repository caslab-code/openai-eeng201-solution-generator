{
    "Question A": {
        "question": "Implement Verilog code for a counter that can count up or down or pause, based on button inputs from the users. The counter can also be enabled or disabled. The current value of the counter will be displayed on four 7- segment displays at the same time. One switch will determine if the counter is enabled or disabled. If the counter is disabled by the switch, the counter will be reset to zero. If the counter is enabled by the switch, 3 buttons, pressed individually, will determine if the counter counts up, counts down, or pauses. 7-segnment display code is provided, also code for a clock divider is provided. All you have to do is to write Verilog code to monitor input buttons and a switch, manage the counter.",
        "answer": "`module count_down_up (\n  // Seven segment output\n  output [6:0] seg_o,\n\n  // Clock signal\n  input clk, \n  \n  // Reset signal\n  input rst,\n  \n  // enable, up, down and pause signal\n  input [3:0] enable_signal\n);\n\n  reg count_enable;\n\n  // Output 4 Digit counter\n  reg [3:0] count_o;\n\n  // Clock divider\n  reg [14:0] clock_div;\n  \n  // Internal FSM signal\n  reg [2:0] state, next_state;\n\n  // Initialize\n  initial begin\n    // Set enable signal to 0\n    count_enable = 0;\n    \n    // Initialize counter output\n    count_o = 4'b0000;\n  \n    // Set clock division register\n    clock_div = 15'b000000000000000;\n\n    // Initialize FSM state\n    state = 3'b000;\n    next_state = 3'b000;\n  end\n  \n  // Clock divider\n  always @ (posedge clk)\n    if (rst)\n      clock_div <= 15'b000000000000000;\n    else\n      clock_div <= clock_div + 1;\n      \n  // Debounce logic\n  always @ (clock_div)\n    if (clock_div == 15'b111100000000000 )\n      begin\n        // Set enable signal based on input\n        count_enable <= enable_signal[0];\n      \n        // Check if the counter is enabled\n        if (enable_signal[0] == 1)\n          begin\n            // Determine which action is taken, e.g. down, up, pause\n            case (enable_signal[1:3])\n              3'b001 : next_state = 3'b001; // Count up\n              3'b010 : next_state = 3'b010; // Count down\n              3'b011 : next_state = 3'b011; // Pause\n            endcase\n          end\n        // If the counter is disabled, reset it\n        else\n          next_state = 3'b000;\n      end\n  \n  // FSM logic to update the count\n  always @ (posedge clk or posedge rst)\n    if (rst)\n      // Reset the state\n      state <= 3'b000;\n    else\n      // Update state based on next_state\n      state <= next_state;\n   \n  // Counter\n  always @ (posedge clk or posedge rst)\n    // Reset counter if counter is disabled\n    if (rst | !count_enable)\n      count_o <= 4'b0000;\n    // Increment counter\n    else if (state == 3'b001)\n      begin\n        // Limit the maximum count\n        if (count_o == 4'b1001)\n          count_o <= 4'b0000;\n        else\n          count_o <= count_o + 4'b0001;\n      end\n    // Decrement counter\n    else if (state == 3'b010)\n      begin\n        // Limit the minimum count\n        if (count_o == 4'b0000)\n          count_o <= 4'b1001;\n        else\n          count_o <= count_o - 4'b0001;\n      end\n\n  // 7-segment Logic\n  // Provide the driving signals for 7-segment display\n  assign seg_o = 7_seg(count_o);\n\n  // Definition of 7-segment display\n  function [6:0] 7_seg (input [3:0] count_i);\n    case (count_i)\n      4'b0000: begin 7_seg = 7'b1000000; end \n      4'b0001: begin 7_seg = 7'b1111001; end \n      4'b0010: begin 7_seg = 7'b0100100; end \n      4'b0011: begin 7_seg = 7'b0110000; end \n      4'b0100: begin 7_seg = 7'b0011001; end \n      4'b0101: begin 7_seg = 7'b0010010; end \n      4'b0110: begin 7_seg = 7'b0000010; end \n      4'b0111: begin 7_seg = 7'b"
    },
    "Execution Time": "0:00:37.320648",
    "OpenAI Parameters": "Model: text-davinci-003, Max. Tokens: 1024, Temperature: 1, N: 1"
}